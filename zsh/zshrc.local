#PATH="/usr/lib/ccache/bin:$PATH:$HOME/.local/bin"
PATH="$PATH:$HOME/.local/bin"
PATH="$PATH:/usr/share/clang/" # Add run-clang-tidy.py and all to PATH

ulimit -c 0 # disable core dumps, but allow enabling them on demand with ulimit -c unlimited

export GCC_COLORS="auto" # for GCC to color diagnostic messages in conjuntion with ccache

# Color in man pages
export LESS_TERMCAP_md=$'\e[01;31m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;44;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[01;32m'

# For crontab -e
export EDITOR=nvim
alias vim='nvim'

alias g='grep -P --line-buffered --color=always'
alias gi='g --ignore-case'
alias l='ls -lAh'
alias o='exo-open'
alias watch='watch -n 0.3'
alias gdb='gdb -q'
alias ninja='nice ninja'
#alias dev='bash -c '"'"'(trap "test build/compile_commands.json -nt compile_commands.json && compdb -p build list > compile_commands.json" EXIT; nice ninja -C build $@)'"'"' ninja'
alias dev='nice ninja -C build'
alias cargo='nice cargo'
alias diff='git diff --no-index'
alias dis='git diff --no-index --ignore-all-space'

dtt() {
    if [ -z "$1" ] || [[ "$1" =~ ^- ]]; then
        meson test -C build "${@}"
    else
        ninja -C build build.ninja --quiet && # rebuild if necessary and print errors
        meson test -C build --list | (fzf --filter "$1" || echo 'No matching tests' >&2) | sed 's@ / @:@' | xargs --no-run-if-empty meson test -C build "${@:2}"
    fi
}

dt() {
    if [ -z "$1" ]; then
        dtt --print-errorlogs
    else
        dtt "$1" --print-errorlogs "${@:2}"
    fi
}

dts() {
    dt "$1" -v --wrapper='strace -ffyyY -s 1000'
}

alias obosim='cd ~/src/obosim/'
alias simlib='cd subprojects/simlib/'

git-rename() {
    git grep -lz -P "$1" | xargs -0 sed -i "s@$1@$2@g"
}

# Warn about dotfiles change
# git -C "$HOME" update-index --refresh > /dev/null || false
# git -C "$HOME" diff-index --quiet HEAD -- || /bin/echo -e '\033[33mdotfiles changed, for backup purposes review, commit and push the changes\033[m'
# [ "$(git -C "$HOME" rev-parse origin/main)" = "$(git -C "$HOME" rev-parse HEAD)" ] || /bin/echo -e '\033[33mdotfiles changes are not pushed\033[m'

function backup() (
    function do_backup() (
        set -euo pipefail
        test -e "$1" || { echo "path does not exist: $1" >&2; return 1; }
        # chdir to the parent folder of the specified path
        cd -P -- "$(dirname -- "$1")"
        # Check if specified path is a file or a directory
        local fname=$(basename -- "$1")
        if [ -f "${fname}" ]; then
            local out_file="$HOME/backup/$(echo "${PWD#$HOME/}/${fname}" | sed 's@/@,@g').tar.zst"
            (
                function rm_tmp() { rm -rf "${out_file}.tmp" }
                trap rm_tmp INT TERM;
                tar --create --zst --file "${out_file}.tmp" "${fname}" &&
                mv "${out_file}.tmp" "${out_file}"
            )
        else
            # chdir to the directory
            cd -P -- "${fname}"
            local out_file="$HOME/backup/$(echo "${PWD#$HOME/}" | sed 's@/@,@g').tar.zst"

            function list_git_files() {
                git ls-files -z --cached --recurse-submodules
                git ls-files -z --others --exclude-standard
                PROJECT_DIR=$PWD git submodule foreach --quiet 'git ls-files -z --others --exclude-standard | while read -d "" x; do echo -n "${PWD#$PROJECT_DIR/}/$x"; echo -ne "\0"; done'
                echo -ne '.git\0'
            }
            function ls_all_files() {
                ls --zero --almost-all
            }
            function filter_existing_files() {
                while read -d '' x; do
                    if [ -e "${x}" ]; then
                        printf '%s\0' "${x}"
                    fi
                done
            }

            if [ -d '.git/' ]; then
                list_git_files
            else
                ls_all_files
            fi | filter_existing_files |
                (
                    function rm_tmp() { rm -rf "${out_file}.tmp" }
                    trap rm_tmp INT TERM;
                    xargs --null tar --create --zst --file "${out_file}.tmp" &&
                    mv "${out_file}.tmp" "${out_file}"
                )
        fi
        du -sh "${out_file}"
    )

    rc=0
    if [ -z "$1" ]; then
        do_backup . || rc=1
    else
        for x in "$@"; do
            do_backup "$x" || rc=1
        done
    fi
    return $rc
)

alias bp="backup"

function transcode_opus {
    local in_file="$1"
    local out_file="$2"
    if [ -z "${out_file}" ]; then
        out_file="${in_file%.*}.opus"
    fi
    echo -e "Transcoding \033[1m${in_file}\033[m into \033[1m${out_file}\033[m"
    nice ffmpeg -i "${in_file}" -c:a libopus -map_metadata 0 "${out_file}"
    #sox "${in_file}" -t wav - | opusenc - "${out_file}"
}
function transcode_opus_all {
    for x in "$@"; do
        transcode_opus "${x}"
    done
}

function transcode_av1 {
    local in_file="$1"
    local out_file="$2"
    if [ -z "${out_file}" ]; then
        out_file="${in_file%.*}.mkv"
    fi
    echo -e "Transcoding \033[1m${in_file}\033[m into \033[1m${out_file}\033[m"
    nice ffmpeg -i "${in_file}" -c:v libsvtav1 -c:a libopus -map_metadata 0 "${out_file}"
}
function transcode_av1_all {
    for x in "$@"; do
        transcode_av1 "${x}"
    done
}

function transcode_avif {
    local in_file="$1"
    local out_file="$2"
    if [ -z "${out_file}" ]; then
        out_file="${in_file%.*}.avif"
    fi
    echo -e "Transcoding \033[1m${in_file}\033[m into \033[1m${out_file}\033[m"
    if [[ "${in_file}" == *.png ]] || [[ "${in_file}" == *.jpg ]] || [[ "${in_file}" == *.jpeg ]]; then
        nice avifenc -j all "${in_file}" "${out_file}"
    else
        (
            tmp_file=$(mktemp --suffix=.jpg) &&
            trap "rm '${tmp_file}'" EXIT &&
            nice convert "${in_file}" -quality 100 "${tmp_file}" &&
            nice avifenc -j all "${tmp_file}" "${out_file}"
        )
    fi
}
function transcode_avif_all {
    for x in "$@"; do
        transcode_avif "${x}"
    done
}

alias speedtest='speedtest --secure'
alias connect='${HOME}/.local/bin/connect-to-wifi.sh'

function setup_github_remotes {
    git remote set-url origin "https://github.com/varqox/$1.git"
    git remote set-url --push origin "git@github.com:varqox/$1.git"
}

function przepis {
    fd '\.(md|html)$' "$HOME/src/przepisy-kulinarne/" | grep -Pv '/README.md' | fzf --exit-0 --print0 | read -r -d '' x && if [[ "$x" == *.html ]]; then firefox --new-window "$x"; else bat "$x"; fi
}

function diff_installed_file() (
    set -euo pipefail
    file="$1"
    pkg=$(pacman -Q --owns --quiet "${file}")
    pkg_version=$(pacman -Qi "${pkg}" | grep '^Version' | sed 's/^Version[^:]*: //')
    pkg_arch=$(pacman -Qi "${pkg}" | grep '^Architecture' | sed 's/^Architecture[^:]*: //')
    /bin/diff <(tar -axf "/var/cache/pacman/pkg/${pkg}-${pkg_version}-${pkg_arch}.pkg.tar.zst" -O "${file#/}") "${file}"
)

function v() {
    bat --force-colorization --paging never "$@"
}

function vl() {
    bat --force-colorization --paging always --pager='less -R' "$@"
}

alias -g -- -h='-h 2>&1 | bash -c "bat --force-colorization --language help" --' # bash -c "..." -- causes all arguments after -h to be ignored but tricks like "| cat" still work!
alias -g -- --help='--help 2>&1 | bash -c "bat --force-colorization --language help" --' # bash -c "..." -- causes all arguments after --help to be ignored but tricks like "| cat" still work!

alias fp='fzf --preview "bat --color=always --style numbers {}"'

function aria {
    aria2c --continue --max-connection-per-server=16 --max-concurrent-downloads=128 --split=1000000 --min-split-size=1M --lowest-speed-limit=1K --stream-piece-selector=random --http-accept-gzip true --enable-http-pipelining true --allow-piece-length-change true --auto-save-interval=16 --download-result=full --file-allocation=falloc --summary-interval=8 --input-file <(printf "%s\n" "$@")
}

function format-drive() (
    if (($# < 2 || $# > 3)); then
        echo 'Usage: format-drive <DEVICE> <FS_TYPE> [NEW_NAME_FOR_THE_SOLE_PARTITION_AND_FILE_SYSTEM]' >&2
        echo 'E.g. format-drive /dev/sdd exfat' >&2
        exit 1
    fi

    device="$1"
    fs_type="$2"

    if [[ -v 3 ]]; then
        name="$3"
    else
        size="$(sudo lsblk "${device}" --output SIZE --nodeps --noheadings)" || exit
        serial="$(sudo udevadm info "${device}" --query=property --property=ID_USB_SERIAL --value)" || exit
        serial_short="$(sudo udevadm info "${device}" --query=property --property=ID_USB_SERIAL_SHORT --value)" || exit
        name="${serial/${serial_short}}"
        name="${name//[^a-zA-Z]/ }"
        name="$(tr --squeeze-repeats ' ' <<< "${name# } ")" || exit
        if [[ "${name}" == " " ]]; then
            echo "warning: could not deduce a sensible name for the device - using an empty one"
            name=''
        else
            name+="${size}"
        fi
    fi

    label_args=()
    extra_args=()

    # Now let's try to decide on label of the file system
    max_fs_label_len=0
    case "${fs_type}" in
        ext2|ext3|ext4)
            max_fs_label_len=16
            label_args=('-L')
            ;;
        exfat)
            max_fs_label_len=11
            label_args=('-L')
            ;;
        vfat)
            max_fs_label_len=11
            label_args=('-n')
            ;;
        ntfs)
            max_fs_label_len=128
            label_args=('-L')
            extra_args+=('--fast')
            ;;
        *)
            if [[ -v 3 ]]; then
                echo "Error: no support yet (TODO) for labeling fs of type: ${fs_type}" >&2
                exit 1
            else
                echo "warning: no support yet (TODO) for labeling fs of type: ${fs_type}, skipping labeling" >&2
                label_args=()
            fi
            ;;
    esac

    if [[ -v 3 ]]; then
        if (( ${#name} > max_fs_label_len )); then
            echo "error: '${name}' is too long for a label (max ${max_fs_label_len} bytes)" >&2
            exit 1
        fi
        label_args+=("${name}")
    else
        fs_label="${name}"
        while (( ${#fs_label} > 0 && ${#fs_label} > ${max_fs_label_len} )); do
            echo "warning: '${fs_label}' is too long for a file system label, will try to trim it..." >&2
            fs_label=" ${fs_label}"
            fs_label="${fs_label% *}"
            fs_label="${fs_label# }"
            echo "warning: Trying '${fs_label}'" >&2
        done
        if (( ${#fs_label} > 0 )); then
            label_args+=("${fs_label}")
        else
            echo "warning: all attempts were too long... won't set the label" >&2
            label_args=()
        fi
    fi

    sudo parted "${device}" 'mktable gpt' || exit
    sudo parted "${device}" "mkpart '${name}' 0% 100%" || exit
    partition_device="$(echo "${device}"?*)"

    sudo mkfs --verbose --type "${fs_type}" "${label_args[@]}" "${extra_args[@]}" "${partition_device}" || exit
    sync
    echo "Done." >&2
)

function share-files() (
    key_file="$(mktemp)" || exit
    cert_file="$(mktemp)" || exit
    trap 'exit $?' SIGINT SIGTERM SIGQUIT SIGHUP || exit
    trap 'rm -f "${key_file}" "${cert_file}"; rm -d "${dir}" 2> /dev/null' EXIT || exit
    dir="${1-${HOME}/tmp/share-files $(date '+%Y-%m-%d %H:%M:%S')}" || exit
    openssl req -x509 -utf8 -days 32 -keyout "${key_file}" -outform PEM -out "${cert_file}" -batch -noenc || exit
    mkdir -p "${dir}" || exit
    random_token="$(openssl rand --hex 16)" || exit
    swaymsg exec xdg-open "'${dir}'" || exit
    addresses=($(ip route list | sed --silent '/^default /s/.* src \([0-9.]*\) .*/\1/p')) || exit
    declare -i port=0
    while (( port == 0 )); do
        port="$(("0x$(openssl rand --hex 2)" % 10000 + 10000))" || exit
        for addr in "${addresses[@]}"; do
            nc --zero "${addr}" "${port}" && {
                port=0
                break
            }
        done
    done

    interfaces=()
    for addr in "${addresses[@]}"; do
        interfaces+=(
            '--interfaces'
            "${addr}"
        )
    done

    miniserve \
        --port "${port}" \
        --route-prefix "${random_token}" \
        --no-symlinks \
        --hidden \
        --qrcode \
        --upload-files \
        --web-upload-files-concurrency 16 \
        --dirs-first \
        --tls-key "${key_file}" \
        --tls-cert "${cert_file}" \
        "${interfaces[@]}" \
        "${dir}"
)

function add-default-subtitles {
    if (( $# != 3 )); then
        echo "usage: add-default-subtitles <input_movie> <subtitles> <output_movie>" >&2
        return 1
    fi

    if grep --quiet '\bpl\b' <<< "$2"; then
        local subs_lang='pol'
    else
        local subs_lang='eng'
    fi

    local number_of_subs_in_the_input="$(ffprobe -loglevel error -select_streams s -show_entries stream=index -of csv=p=0 "$1")" || return 1
    number_of_subs_in_the_input="$(wc -l <<< "${number_of_subs_in_the_input}")" || return 1

    case "${3##*.}" in
        mkv)
            local subs_codec=srt
            ;;
        mp4)
            local subs_codec=mov_text
            ;;
        *)
            echo "Unknown output movie format" >&2
            return 1
            ;;
    esac

    local options=(
        -i "$1"
        -i "$2"
        -map 0 # use first input
        -map 1 # use second input
        -c:v copy # copy video
        -c:a copy # copy audio
        -c:s "${subs_codec}" # copy subtitles
        -metadata:s:s:"${number_of_subs_in_the_input}" language="${subs_lang}"
        -metadata:s:s:"${number_of_subs_in_the_input}" title="${2%.*}"
        -metadata:s:s:"${number_of_subs_in_the_input}" default=yes
        "$3"
    )

    ffmpeg "${options[@]}"
}

function burn-subtitles {
    if (( $# != 3 )); then
        echo "usage: burn-subtitles <input_movie> <subtitles> <output_movie>" >&2
        return 1
    fi

    local options=(
        -i "$1"
        -c:v libx264 # x264 CPU encoder
        -crf 20 # very good quality
        -preset veryslow # very high compression
        -tune grain # retain small details
        -deblock -1:-1 # less removing of block artifacts for retaining details
        -vf subtitles="$2" # burn subtitles into the video
        -c:a copy # copy audio
        -sn # remove all subtitles
        "$3"
    )

    ffmpeg "${options[@]}"
}

function change-movie-format {
    if (( $# != 2 )); then
        printf "usage: change-movie-format <input_movie> <output_movie>\nE.g. change-movie-format input.mkv output.mp4\n" >&2
        return 1
    fi

    ffmpeg "$1" -codec copy "$2"
}
